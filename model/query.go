// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package model

import "fmt"
import "reflect"
import "encoding/json"

// Query is a query against the NOSQL database - it does not support full text
// search
type QueryJson struct {
	// the collection to query
	From string `json:"from"`

	// GroupBy corresponds to the JSON schema field "groupBy".
	GroupBy []string `json:"groupBy,omitempty"`

	// Limit corresponds to the JSON schema field "limit".
	Limit *int `json:"limit,omitempty"`

	// OrderBy corresponds to the JSON schema field "orderBy".
	OrderBy []QueryJsonOrderByElem `json:"orderBy,omitempty"`

	// Page corresponds to the JSON schema field "page".
	Page *int `json:"page,omitempty"`

	// Select corresponds to the JSON schema field "select".
	Select []QueryJsonSelectElem `json:"select"`

	// Where corresponds to the JSON schema field "where".
	Where []QueryJsonWhereElem `json:"where,omitempty"`
}

// orderBy orders results by a field and a direction
type QueryJsonOrderByElem struct {
	// Direction corresponds to the JSON schema field "direction".
	Direction QueryJsonOrderByElemDirection `json:"direction"`

	// Field corresponds to the JSON schema field "field".
	Field string `json:"field"`
}

type QueryJsonOrderByElemDirection string

const QueryJsonOrderByElemDirectionAsc QueryJsonOrderByElemDirection = "asc"
const QueryJsonOrderByElemDirectionDesc QueryJsonOrderByElemDirection = "desc"

// select is a list of fields to select from each record in the datbase(optional)
type QueryJsonSelectElem struct {
	// an aggregate function to apply against the field
	Aggregate *QueryJsonSelectElemAggregate `json:"aggregate,omitempty"`

	// as is outputs the value of the field as an alias
	As *string `json:"as,omitempty"`

	// the select's field
	Field string `json:"field"`

	// a function to apply against the field
	Function *QueryJsonSelectElemFunction `json:"function,omitempty"`
}

type QueryJsonSelectElemAggregate string

const QueryJsonSelectElemAggregateCount QueryJsonSelectElemAggregate = "count"
const QueryJsonSelectElemAggregateMax QueryJsonSelectElemAggregate = "max"
const QueryJsonSelectElemAggregateMin QueryJsonSelectElemAggregate = "min"
const QueryJsonSelectElemAggregateSum QueryJsonSelectElemAggregate = "sum"

type QueryJsonSelectElemFunction string

const QueryJsonSelectElemFunctionToLower QueryJsonSelectElemFunction = "toLower"
const QueryJsonSelectElemFunctionToUpper QueryJsonSelectElemFunction = "toUpper"

// where is a filter applied against a query
type QueryJsonWhereElem struct {
	// Field corresponds to the JSON schema field "field".
	Field string `json:"field"`

	// Op corresponds to the JSON schema field "op".
	Op QueryJsonWhereElemOp `json:"op"`

	// Value corresponds to the JSON schema field "value".
	Value interface{} `json:"value"`
}

type QueryJsonWhereElemOp string

const QueryJsonWhereElemOpContains QueryJsonWhereElemOp = "contains"
const QueryJsonWhereElemOpEq QueryJsonWhereElemOp = "eq"
const QueryJsonWhereElemOpGt QueryJsonWhereElemOp = "gt"
const QueryJsonWhereElemOpGte QueryJsonWhereElemOp = "gte"
const QueryJsonWhereElemOpIn QueryJsonWhereElemOp = "in"

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryJsonOrderByElemDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QueryJsonOrderByElemDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QueryJsonOrderByElemDirection, v)
	}
	*j = QueryJsonOrderByElemDirection(v)
	return nil
}

var enumValues_QueryJsonWhereElemOp = []interface{}{
	"eq",
	"neq",
	"gt",
	"gte",
	"lt",
	"lte",
	"in",
	"contains",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryJsonWhereElemOp) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QueryJsonWhereElemOp {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QueryJsonWhereElemOp, v)
	}
	*j = QueryJsonWhereElemOp(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryJsonSelectElemAggregate) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QueryJsonSelectElemAggregate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QueryJsonSelectElemAggregate, v)
	}
	*j = QueryJsonSelectElemAggregate(v)
	return nil
}

const QueryJsonWhereElemOpNeq QueryJsonWhereElemOp = "neq"

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryJsonSelectElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["field"]; !ok || v == nil {
		return fmt.Errorf("field field: required")
	}
	type Plain QueryJsonSelectElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QueryJsonSelectElem(plain)
	return nil
}

var enumValues_QueryJsonSelectElemAggregate = []interface{}{
	"sum",
	"count",
	"max",
	"min",
}

const QueryJsonWhereElemOpLt QueryJsonWhereElemOp = "lt"
const QueryJsonWhereElemOpLte QueryJsonWhereElemOp = "lte"

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryJsonOrderByElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["direction"]; !ok || v == nil {
		return fmt.Errorf("field direction: required")
	}
	if v, ok := raw["field"]; !ok || v == nil {
		return fmt.Errorf("field field: required")
	}
	type Plain QueryJsonOrderByElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QueryJsonOrderByElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryJsonSelectElemFunction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QueryJsonSelectElemFunction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QueryJsonSelectElemFunction, v)
	}
	*j = QueryJsonSelectElemFunction(v)
	return nil
}

var enumValues_QueryJsonSelectElemFunction = []interface{}{
	"toLower",
	"toUpper",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryJsonWhereElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["field"]; !ok || v == nil {
		return fmt.Errorf("field field: required")
	}
	if v, ok := raw["op"]; !ok || v == nil {
		return fmt.Errorf("field op: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain QueryJsonWhereElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QueryJsonWhereElem(plain)
	return nil
}

var enumValues_QueryJsonOrderByElemDirection = []interface{}{
	"asc",
	"desc",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QueryJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["from"]; !ok || v == nil {
		return fmt.Errorf("field from: required")
	}
	if v, ok := raw["select"]; !ok || v == nil {
		return fmt.Errorf("field select: required")
	}
	type Plain QueryJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = QueryJson(plain)
	return nil
}
